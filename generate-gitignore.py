#!/usr/bin/env python
# generate-gitignore.py
# GusE 2014.04.17 V0.1
"""
Generate gitignore files intelligently based off of the directory contents
"""
__version__ = "1.0"

import getopt
import sys
import os
import subprocess
import traceback
import logging
import logging.handlers
import tempfile
import argparse

__app__ = os.path.basename(__file__)
__author__ = "Gus E"
__copyright__ = "Copyright 2014"
__credits__ = ["Gus E"]
__license__ = "GPL"
__maintainer__ = "Gus E"
__email__ = "gesquive@gmail"
__status__ = "Beta"

script_www = 'https://github.com/gesquive/generate-gitignore'
script_url = 'https://raw.github.com/gesquive/generate-gitignore/master/generate-gitignore.py'

#--------------------------------------
# Configurable Constants
LOG_FILE = '/var/log/' + os.path.splitext(__app__)[0] + '.log'
LOG_SIZE = 1024*1024*200

verbose = False
debug = False

logger = logging.getLogger(__app__)

#TODO: Add a way to force a certain tag into the gitignore
#TODO: Allow user to just append to an existing gitignore file
#TODO: Allow users to preview gitignore editing/appending
#TODO: Perhaps allow a user edited part of the gitignore that isn't overwritten
#TODO: Add a "generated by" message to the gitignore

def main():
    global verbose, debug

    ## Argument Parsing ########################################################
    parser = argparse.ArgumentParser(add_help=False,
        description="Generate gitignore files intelligently based "
        "off of the directory contents.",
        epilog="%(__app__)s v%(__version__)s\n" % globals())

    group = parser.add_argument_group("Options")
    group.add_argument("-h", "--help", action="help",
        help="Show this help message and exit.")
    group.add_argument("-v", "--verbose", action="store_true", dest="verbose",
        help="Writes all messages to console.")
    group.add_argument("-D", "--debug", action="store_true", dest="debug",
        help=argparse.SUPPRESS)
    group.add_argument("-l", "--log-file", dest="log_file", default=LOG_FILE)
    group.add_argument("-u", "--update", action="store_true", dest="update",
        help="Checks server for an update, replaces the current version if "\
        "there is a newer version available.")
    group.add_argument("-V", "--version", action="version",
                    version="%(__app__)s v%(__version__)s" % globals())

    group = parser.add_argument_group("Generate Options")
    # group.add_argument("tags", nargs="?", help="Any additional languages "
    #     "to include.", choices=["os", "python", "c++", "c", "java", "perl",
    #     "qt", "android", "eclipse", "mercurial", "svn", "sublime-text",
    #     "linux", "vim", "virtualenv", "autoconf"])
    group.add_argument("-d", "--directory", dest="directory",
        type=str, default=os.getcwd(),
        help="The directory to search and save the gitignore file into.")
    group.add_argument("-f", "--force", action="store_true", dest="force",
        help="Overwrite a previous gitignore if it exists.")

    args = parser.parse_args()
    verbose = args.verbose
    debug = args.debug

    if args.update:
        update(script_url)
        sys.exit(0)


    ## Log File Config #########################################################
    log_file = LOG_FILE
    if not os.access(log_file, os.W_OK):
        # Couldn't write to the given log file, try writing a temporary one instead
        log_file = os.path.join(tempfile.gettempdir(),
            os.path.splitext(__app__)[0] + '.log')
        if not os.access(os.path.dirname(log_file), os.W_OK):
            print "ERROR: Cannot write to '%(log_file)s'.\nExiting." % locals()
            sys.exit(2)
    file_handler = logging.handlers.RotatingFileHandler(log_file,
                                            maxBytes=LOG_SIZE, backupCount=9)
    file_formater = logging.Formatter('%(asctime)s,%(levelname)s,%(thread)d,%(message)s')
    file_handler.setFormatter(file_formater)
    logger.addHandler(file_handler)

    if verbose:
        console_handler = logging.StreamHandler(sys.stdout)
        console_formatter = logging.Formatter("[%(asctime)s] %(levelname)-5.5s: %(message)s")
        console_handler.setFormatter(console_formatter)
        logger.addHandler(console_handler)

    if debug:
        logger.setLevel(logging.DEBUG)
        logger.debug("Debug mode activated.")
    else:
        logger.setLevel(logging.INFO)

    try:
        # Here is where the magic happens
        dir_path = args.directory
        found_tags = parse_directory(dir_path)
        ignore_contents = generate_gitignore(found_tags)
        ignore_path = get_gitignore_path(dir_path)
        if args.force or not os.path.exists(ignore_path) or (os.path.exists(ignore_path) and \
            query_yes_no("gitignore files already exists, overwrite?", default="no")):
            write_gitignore(ignore_path, ignore_contents)

    except (KeyboardInterrupt, SystemExit):
        pass
    except Exception, e:
        print traceback.format_exc()


import re
def parse_directory(dir_path):
    """
    Parses through the given directory looking for hints of what to ignore
    Returns the tags corresponding too files found
    """

    sys.stdout.write("Collecting stats...")
    sys.stdout.flush()
    file_count = 0
    for root, dirs, files in os.walk(dir_path, topdown=True):
        for name in files:
            file_count += 1
    sys.stdout.write("\r                   ")

    all_tags = []

    curr_count = 0
    for root, dirs, files in os.walk(dir_path, topdown=True):
        # based on the file name, choose if we need to include a tag or not
        for name in files:
            curr_count += 1
            sys.stdout.write("\r%d/%d" %(curr_count, file_count))
            # print(os.path.join(root, name))

            for tag, regex in FILE_REGEX.iteritems():
                if re.search(regex, name, re.IGNORECASE):
                    all_tags.append(tag)

        for name in dirs:
            # print(os.path.join(root, name))
            for tag, regex in DIR_REGEX.iteritems():
                if re.search(regex, name, re.IGNORECASE):
                    all_tags.append(tag)


    tags = set(all_tags)
    print "\nFound the following sets: " + ", ".join(sorted(tags))

    return sorted(tags)


def generate_gitignore(tags):
    """
    Generates a gitignore file based off of the given tags.
    Returns the contents of the gitignore
    """
    gitignore = ""

    for tag in tags:
        if tag in GIT_DEFS:
            gitignore += GIT_DEFS[tag] + "\n"

    return gitignore


def get_gitignore_path(dir_path):
    """
    Generates and returns the path of the gitignore file based of the directory path
    """
    return os.path.join(dir_path, ".gitignore")


def write_gitignore(path, contents):
    gitignore = open(path, "w")
    gitignore.write(contents)


def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is one of "yes" or "no".
    """
    valid = {"yes":True,   "y":True,  "ye":True,
             "no":False,     "n":False}
    if default == None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "\
                             "(or 'y' or 'n').\n")


def update(dl_url, force_update=False):
    """
Attempts to download the update url in order to find if an update is needed.
If an update is needed, the current script is backed up and the update is
saved in its place.
"""
    import urllib
    import re
    from subprocess import call
    def compare_versions(vA, vB):
        """
Compares two version number strings
@param vA: first version string to compare
@param vB: second version string to compare
@author <a href="http_stream://sebthom.de/136-comparing-version-numbers-in-jython-pytho/">Sebastian Thomschke</a>
@return negative if vA < vB, zero if vA == vB, positive if vA > vB.
"""
        if vA == vB: return 0

        def num(s):
            if s.isdigit(): return int(s)
            return s

        seqA = map(num, re.findall('\d+|\w+', vA.replace('-SNAPSHOT', '')))
        seqB = map(num, re.findall('\d+|\w+', vB.replace('-SNAPSHOT', '')))

        # this is to ensure that 1.0 == 1.0.0 in cmp(..)
        lenA, lenB = len(seqA), len(seqB)
        for i in range(lenA, lenB): seqA += (0,)
        for i in range(lenB, lenA): seqB += (0,)

        rc = cmp(seqA, seqB)

        if rc == 0:
            if vA.endswith('-SNAPSHOT'): return -1
            if vB.endswith('-SNAPSHOT'): return 1
        return rc

    # dl the first 256 bytes and parse it for version number
    try:
        http_stream = urllib.urlopen(dl_url)
        update_file = http_stream.read(256)
        http_stream.close()
    except IOError, (errno, strerror):
        print "Unable to retrieve version data"
        print "Error %s: %s" % (errno, strerror)
        return

    match_regex = re.search(r'__version__ *= *"(\S+)"', update_file)
    if not match_regex:
        print "No version info could be found"
        return
    update_version = match_regex.group(1)

    if not update_version:
        print "Unable to parse version data"
        return

    if force_update:
        print "Forcing update, downloading version %s..." \
            % update_version
    else:
        cmp_result = compare_versions(__version__, update_version)
        if cmp_result < 0:
            print "Newer version %s available, downloading..." % update_version
        elif cmp_result > 0:
            print "Local version %s newer then available %s, not updating." \
                % (__version__, update_version)
            return
        else:
            print "You already have the latest version."
            return

    # dl, backup, and save the updated script
    app_path = os.path.realpath(sys.argv[0])

    if not os.access(app_path, os.W_OK):
        print "Cannot update -- unable to write to %s" % app_path

    dl_path = app_path + ".new"
    backup_path = app_path + ".old"
    try:
        dl_file = open(dl_path, 'w')
        http_stream = urllib.urlopen(dl_url)
        total_size = None
        bytes_so_far = 0
        chunk_size = 8192
        try:
            total_size = int(http_stream.info().getheader('Content-Length').strip())
        except:
            # The header is improper or missing Content-Length, just download
            dl_file.write(http_stream.read())

        while total_size:
            chunk = http_stream.read(chunk_size)
            dl_file.write(chunk)
            bytes_so_far += len(chunk)

            if not chunk:
                break

            percent = float(bytes_so_far) / total_size
            percent = round(percent*100, 2)
            sys.stdout.write("Downloaded %d of %d bytes (%0.2f%%)\r" %
                (bytes_so_far, total_size, percent))

            if bytes_so_far >= total_size:
                sys.stdout.write('\n')

        http_stream.close()
        dl_file.close()
    except IOError, (errno, strerror):
        print "Download failed"
        print "Error %s: %s" % (errno, strerror)
        return

    try:
        os.rename(app_path, backup_path)
    except OSError, (errno, strerror):
        print "Unable to rename %s to %s: (%d) %s" \
            % (app_path, backup_path, errno, strerror)
        return

    try:
        os.rename(dl_path, app_path)
    except OSError, (errno, strerror):
        print "Unable to rename %s to %s: (%d) %s" \
            % (dl_path, app_path, errno, strerror)
        return

    try:
        import shutil
        shutil.copymode(backup_path, app_path)
    except:
        os.chmod(app_path, 0755)

    print "New version installed as %s" % app_path
    print "(previous version backed up to %s)" % (backup_path)
    return


FILE_REGEX = {}
FILE_REGEX['linux-tmp'] = r'^.*(\.(tmp|bak|swp)|~)$'
FILE_REGEX['windows-tmp'] = r'^.*(\.(cab|msi|msm|msp)|'\
    '(Thumbs.db|ehthumbs.db|Desktop.ini))$'

FILE_REGEX['c++'] = r'^.*\.(c|cc|cp|cpp|c\+\+|cxx|h|hh|hpp|inl|o|obj)$'
FILE_REGEX['python'] = r'^.*\.(py|py[cod]|mo)$'
FILE_REGEX['python-pkg'] = r'^.*\.(egg|installed\.cfg|Python)$'
FILE_REGEX['perl'] = r'^.*\.(pl)$'
FILE_REGEX['java'] = r'^.*\.(java|class)$'

FILE_REGEX['android'] = r'^.*\.(apk|ap_|dex|local\.properties)$'
FILE_REGEX['qt'] = r'^.*\.(qtcreator|qmake\.cache|qmake\.stash|'\
    'pro\.user|moc|autosave)$'

FILE_REGEX['eclipse'] = r'^.*\.(metadata|gradle|loadpath|cproject|buildpath|'\
    'target|texlipse)$'
FILE_REGEX['sublime-text'] = r'^.*\.(sublime-workspace|'\
    'sublime-project|sftp-config.json)$'
FILE_REGEX['vim'] = r'^.*\.(vim|netrwhist)$'

FILE_REGEX['cvs'] = r'^.*\.(cvsignore)$'
FILE_REGEX['mercurial'] = r'^.*\.(hgignore)$'


DIR_REGEX = {}
DIR_REGEX['windows-tmp'] = r'^(\$RECYCLE.BIN)$'

DIR_REGEX['java'] = r'^(\.mtj\.tmp)$'
DIR_REGEX['python'] = r'^(__init__|__pycache__)$'

DIR_REGEX['cvs'] = r'^CVS$'
DIR_REGEX['svn'] = r'^\.svn$'
DIR_REGEX['mercurial'] = r'^\.hg$'

GIT_DEFS = {}
# The gitignore files generated are based off of the project at https://github.com/github/gitignore
# DO NOT MODIFY THE FOLLOWING AUTO-GENERATED SECTION - CHANGES WILL BE OVERWRITTEN
## GITIGNORE DEFS

GIT_DEFS['linux-tmp'] = '## Linux Temporary Files\n*~\n*.tmp\n*.bak\n*.swp\n\n# KDE directory preferences\n.directory\n'
GIT_DEFS['windows-tmp'] = '## Windows Temporary Files\n# Windows image file caches\nThumbs.db\nehthumbs.db\n\n# Folder config file\nDesktop.ini\n\n# Recycle Bin used on file shares\n$RECYCLE.BIN/\n\n# Windows Installer files\n*.cab\n*.msi\n*.msm\n*.msp\n'

GIT_DEFS['c++'] = '## C/C++ Files\n# Compiled Object files\n*.o\n*.obj\n*.lo\n*.slo\n*.elf\n\n# Compiled Dynamic libraries\n*.so\n*.so.*\n*.dylib\n*.dll\n\n# Compiled Static libraries\n*.a\n*.lib\n*.la\n*.lai\n\n# Executables\n*.exe\n*.out\n*.app\n*.i*86\n*.x86_64\n*.hex'
GIT_DEFS['java'] = '## Java Files\n*.class\n\n# Mobile Tools for Java (J2ME)\n.mtj.tmp/\n\n# Package Files #\n*.jar\n*.war\n*.ear\n\n# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml\nhs_err_pid*\n'
GIT_DEFS['python'] = '## Python Files\n# Byte-compiled / optimized / DLL files\n__pycache__/\n*.py[cod]\n\n# Translations\n*.mo\n'
GIT_DEFS['python-pkg'] = '## Python Distribution/Packaging Files\n.Python\nenv/\nbin/\nbuild/\ndevelop-eggs/\ndist/\neggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\n*.egg-info/\n.installed.cfg\n*.egg\n'
GIT_DEFS['perl'] = '## Perl Files\n/blib/\n/.build/\n_build/\ncover_db/\ninc/\nBuild\n!Build/\nBuild.bat\n.last_cover_stats\n/MANIFEST.bak\n/META.yml\n/META.json\n/MYMETA.*\nnytprof.out\n/pm_to_blib\n*.o\n*.bs\n'

GIT_DEFS['android'] = '## Android Files\n# Built application files\n*.apk\n*.ap_\n\n# Files for the Dalvik VM\n*.dex\n\n# Generated files\nbin/\ngen/\n\n# Gradle files\n.gradle/\nbuild/\n\n# Local configuration file (sdk path, etc)\nlocal.properties\n\n# Proguard folder generated by Eclipse\nproguard/\n'
GIT_DEFS['django'] = '## Django Files\n*.log\n*.pot\n\n'
GIT_DEFS['pip'] = '## PIP Files\npip-log.txt\npip-delete-this-directory.txt\n'
GIT_DEFS['qt'] = '## QT Files\n# Qt-es\n/.qmake.cache\n/.qmake.stash\n*.pro.user\n*.pro.user.*\n*.moc\nmoc_*.cpp\nqrc_*.cpp\nui_*.h\nMakefile*\n*-build-*\n\n# QtCreator\n*.autosave\n'

GIT_DEFS['eclipse'] = '## Eclipse Files\n*.pydevproject\n.metadata\n.gradle\nbin/\ntmp/\n*.tmp\n*.bak\n*.swp\n*~.nib\nlocal.properties\n.settings/\n.loadpath\n\n# External tool builders\n.externalToolBuilders/\n\n# Locally stored "Eclipse launch configurations"\n*.launch\n\n# CDT-specific\n.cproject\n\n# PDT-specific\n.buildpath\n\n# sbteclipse plugin\n.target\n\n# TeXlipse plugin\n.texlipse\n'
GIT_DEFS['sublime-text'] = '## Sublime Text Files\n*.sublime-workspace\n\n# project files should be checked into the repository, unless a significant\n# proportion of contributors will probably not be using SublimeText\n#*.sublime-project\n'
GIT_DEFS['vim'] = '## Vim Files\n[._]*.s[a-w][a-z]\n[._]s[a-w][a-z]\n*.un~\nSession.vim\n.netrwhist\n*~\n'

GIT_DEFS['cvs'] = '## CVS Files\n/CVS/*\n*/CVS/*\n.cvsignore\n*/.cvsignore\n'
GIT_DEFS['svn'] = '## SVN Files\n.svn/\n'
GIT_DEFS['mercurial'] = '## Mercurial Files\n/.hg/*\n*/.hg/*\n.hgignore\n'

## GITIGNORE DEFS END


if __name__ == '__main__':
    main()
